#PARSE_ESCAPES
itemGroup.rs_ctr=Redstone Control
# Blocks
# names & tooltips
tile.rs_ctr.rs_port\:0.name=Redstone Read Socket
tile.rs_ctr.rs_port\:0.tip=Attach on block surface to read its emitted Redstone signal.\nCan be combined with a §6Write Socket§7 on the same surface.\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:1.name=Redstone Write Socket
tile.rs_ctr.rs_port\:1.tip=Attach on block surface to control the Redstone signal it receives.\nCan be combined with either a §6Read Socket§7 or another §6Write Socket§7 on the same surface (two Write Sockets combined will emit a strong signal that penetrates solid blocks).\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.splitter.name=Signal 4x Splitter
tile.rs_ctr.splitter.tip=Repeats the incoming signal to four different destinations (no delay).
tile.rs_ctr.analog_comb.name=Analog Signal Combiner
tile.rs_ctr.analog_comb.tip=Combines the 4 incoming signals by outputing the one with highest value.
tile.rs_ctr.logic_comb.name=Logic Signal Combiner
tile.rs_ctr.logic_comb.tip=Combines the for incomming signals by logical §eOR§7, where the outputs will emit §e65536§7 for §etrue§7 and §e0§7 for §efalse§7.\nThe output as well as each individual input can be set to inverted which also gives you the other logic-gate types §eAND§7, §eNAND§7 and §eNOR§7. 
tile.rs_ctr.num_comb.name=Arithmetic Signal Combiner
tile.rs_ctr.num_comb.tip=Combines the 4 incomming signals by adding their values together.\nInputs can be negated which allows computing subtractions too.
tile.rs_ctr.bin_comb.name=Binary Signal Packer
tile.rs_ctr.bin_comb.tip=The output signal results from concatenating the binary representations of the 4 input signals. How many bits are taken from each input signal is configurable\:\n§e1 bit§7 only distinguishes between §e0§7 and §e1\\n§e2 bit§7 distinguishes between §e0§7, §e1§7, §e2§7 und §e3\\n§e4 bit§7 distinguishes the values §e0§7 - §e15\\n§e8 bit§7 distinguishes the values §e0§7 - §e255\n§oOnly values within the given range can be losslessly retrieved later on by a §6§oBinary Signal Unpacker§7§o.
tile.rs_ctr.bin_split.name=Binary Signal Unpacker
tile.rs_ctr.bin_split.tip=Works the opposite way of the §6Binary Signal Packer§7\:\nThe binary representation of the input signal is split into 4 pieces of §e1§7, §e2§7, §e4§7 or §e8 bit§7 each (depending on setting) which then form the individual output signals.\n\n§oThis makes it possible to send multiple signals through a shared wire. Also the operation of a §6§oLogic Signal Combiner§7§o in §e§obitwise§7§o-mode runs for all packed signals in parallel.
tile.rs_ctr.wire_anchor.name=Wire Anchor
tile.rs_ctr.wire_anchor.tip=§6Signal Wire§7s can be attached on these to customize their path.\n§oMultiple of them may be placed inside a single block.
tile.rs_ctr.processor.tip=Compact circuit that's programmable with the §6Circuit Designer§7.\nOffers up to §16 Input§7 and §26 Output§7 ports.
tile.rs_ctr.processor.name=Redstone Processor
tile.rs_ctr.editor.name=Circuit Designer
tile.rs_ctr.editor.tip=Used to program assembled §6Processor§7s.
tile.rs_ctr.comparator.name=Remote Comparator
tile.rs_ctr.comparator.tip=Whenever the value of §eClock IN§7 changes, §eOUT§7 will be updated to the current comparator value read from §eBlock IN§7.
tile.rs_ctr.energy_reader.name=Energy Reader
tile.rs_ctr.energy_reader.tip=Whenever the value of §eClock IN§7 changes, §eOUT§7 will be updated to the current amount of energy stored in §eBlock IN§7.\nSupported energy types\: §3RF/FE/IF§7, §3EU
tile.rs_ctr.item_reader.name=Item Reader
tile.rs_ctr.fluid_reader.tip=Whenever the value of §eClock IN§7 changes, §eOUT§7 will be updated to the current amount of §3mB§7 fluid stored in §eBlock IN§7.
tile.rs_ctr.fluid_reader.name=Fluid Reader
tile.rs_ctr.item_reader.tip=Whenever the value of §eClock IN§7 changes, §eOUT§7 will be updated to the current amount of items stored in §eBlock IN§7.

# chat messages
msg.rs_ctr.type=§cIncompatible socket type!
msg.rs_ctr.wire0=§cInputs can only connect to outputs and vice versa!
msg.rs_ctr.wire1=§cToo far away, not enough wire!
msg.rs_ctr.wire2=§cToo far away, max length is %d blocks!
msg.rs_ctr.wire3=§cFirst port doesn't exist anymore!
msg.rs_ctr.const=§cConstants can only connect to inputs!
msg.rs_ctr.lamp=§cLamps can only connect to outputs!
msg.rs_ctr.save_succ=§aCircuit Schematic successfully saved!
msg.rs_ctr.load_succ=§aCircuit Schematic successfully loaded!
msg.rs_ctr.invalid_file=§cThe selected file does'nt contain Circuit Schematic data!
msg.rs_ctr.no_file§cThe selected file does'nt exist!

# Items
# names & tooltips
item.rs_ctr.wire.name=Signal Wire
item.rs_ctr.wire.tip=§aUse§7 on signal port to attach, then §ause§7 on another signal port of opposite polarity to connect both together.\n§oRequires 1 item per block of straight distance between ports.\n\nConnections are removed by either §ahitting§7 the port or §asneak using§7 it with an §aempty hand§7.
item.rs_ctr.wireless.name=Wireless Signal Connector
item.rs_ctr.wireless.tip=Like a §6Signal Wire§7 but can connect two signal ports over any distance, even across dimensions.
item.rs_ctr.constant.tip=Can be attached to an input port to supply it with a constant signal value.\n§aUse§7 in air to configure value.
item.rs_ctr.constant.name=Constant Plug
item.rs_ctr.lamp.name=Signal Status Lamp
item.rs_ctr.lamp.tip=Attach on output port to see its signal state.
item.rs_ctr.tag.name=Wire Tag
item.rs_ctr.tag.tip=§aUse§7 in air to set name.\n§aUse§7 on connected port to rename its signal connection. It will then show the name instead of an ID.
item.rs_ctr.block_wire.name=Block Probe Wire
item.rs_ctr.block_wire.tip=Used to connect block faces to devices like Sensors, etc.
item.rs_ctr.clock.name=Clock Plug
item.rs_ctr.clock.tip=Emits a continuous square-wave singal into the port it's attached to. Switching between §e65535§7 and §e0§7.\n§aUse§7 in air configure pulse width and phase.\n§oAll clocks in the world are synchronized.
item.rs_ctr.processor.stats=Complexity\: §c%d §b%d §e%d §7Size\: §f%d

#Signal port names
port.rs_ctr.rsR=Read
port.rs_ctr.rsW=Write
port.rs_ctr.i=IN
port.rs_ctr.i0=IN 0\n§oleast significant
port.rs_ctr.i1=IN 1
port.rs_ctr.i2=IN 2
port.rs_ctr.i3=IN 3\n§omost significant
port.rs_ctr.o=OUT
port.rs_ctr.o0=OUT 0\n§oleast significant
port.rs_ctr.o1=OUT 1
port.rs_ctr.o2=OUT 2
port.rs_ctr.o3=OUT 3\n§omost significant
port.rs_ctr.num0=positive
port.rs_ctr.num1=negative
port.rs_ctr.logic0=x > 0
port.rs_ctr.logic1=x <\= 0
port.rs_ctr.logic2=bit-wise
port.rs_ctr.logic3=bit-wise\ninverted
port.rs_ctr.logic4=OR
port.rs_ctr.logic5=NOR
port.rs_ctr.bin4=4x4bit -> 16bit
port.rs_ctr.bin2=4x2bit -> 8bit
port.rs_ctr.bin1=4x1bit -> 4bit
port.rs_ctr.bin8=4x8bit -> 32bit
port.rs_ctr.bins1=4bit -> 4x1bit
port.rs_ctr.bins2=8bit -> 4x2bit
port.rs_ctr.bins4=16bit -> 4x4bit
port.rs_ctr.bins8=32bit -> 4x8bit
port.rs_ctr.clk=Clock IN
port.rs_ctr.bi=Block IN
port.rs_ctr.clock=⎍ %.2fs
port.rs_ctr.energy1=Industrialcraft EU
port.rs_ctr.energy0=Forge Energy\nRedstone Flux

#Circuit gates
gate.cost=§8Complexity\: §c%d §b%d
gategroup.rs_ctr.io=Variables & IO
gate.rs_ctr.in=Input Socket\n§7receives external sinals
gate.rs_ctr.out=Output Socket\n§7emits external signals
gate.rs_ctr.write=Variable Write\n§7Stores input in a variable to\n§7feed into next evaluation cycle
gate.rs_ctr.read=Variable read\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.i_cst=Constant Number\n§7out \= #
gategroup.rs_ctr.logic=Logic
gate.rs_ctr.or=OR-Gate\n§7out \= in1 ∨ in2\n§7bitwise
gate.rs_ctr.nand=NAND-Gate\n§7out \= ¬(in1 ∧ in2)\n§7bitwise
gate.rs_ctr.xor=XOR-Gate\n§7out \= in1 ⊻ in2\n§7bitwise
gate.rs_ctr.nor=NOR-Gate\n§7in \= ¬(in1 ∨ in2)\n§7bitwise
gate.rs_ctr.not=NOT-Gate\n§7out \= ¬in\n§7bitwise
gate.rs_ctr.and=AND-Gate\n§7out \= in1 ∧ in2\n§7bitwise
gate.rs_ctr.xnor=XNOR-Gate\n§7in \= ¬(in1 ⊻ in2)\n§7bitwise
gategroup.rs_ctr.comp=Comparators
gate.rs_ctr.nsgn=Is Negative\n§7in < 0 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.psgn=Not Negative\n§7in < 0 -> out \= 0\n§7else -> out \= -1
gate.rs_ctr.is0=Is Zero\n§7in \= 0 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.not0=Not Zero\n§7in \= 0 -> out \= 0\n§7else -> out \= -1
gate.rs_ctr.neq=Not Equal\n§7in1 \= in2 -> out \= 0\n§7else -> out \= -1
gate.rs_ctr.ls=Less than\n§7in1 < in2 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.eq=Equal\n§7in1 \= in2 -> out \= -1\n§7else -> out \= 0
gate.rs_ctr.geq=Greater or Equal\n§7in1 < in2 -> out \= 0\n§7else -> out \= -1
gategroup.rs_ctr.num=Arithmetic
gate.rs_ctr.neg=Negate\n§7out \= -in
gate.rs_ctr.sub=Subtract\n§7out \= in1 - in2
gate.rs_ctr.add=Add\n§7out \= in1 + in2
gate.rs_ctr.div=Divide\n§7out \= in1 / in2\n§7rounding down\n§4§oDiv/0 causes burnout!
gate.rs_ctr.dec=Decrement\n§7out \= in - 1
gate.rs_ctr.abs=Absolute value\n§7in < 0 -> out \= -in\n§7else -> out \= in
gate.rs_ctr.mul=Multiply\n§7out \= in1 * in2
gate.rs_ctr.inc=Increment\n§7out \= in + 1
gate.rs_ctr.mod=Div Remainder\n§7out \= in1 mod in2\n§7sgn(out) \= sgn(in1)\n§4§oDiv/0 causes burnout!
gate.rs_ctr.min=Minimum\n§7in1 < in2 -> out \= in1\n§7else -> out \= in2
gate.rs_ctr.max=Maximum\n§7in1 > in2 -> out \= in1\n§7else -> out \= in2

# GUI
# Inventory names
gui.rs_ctr.constant.name=Set Value
gui.rs_ctr.tag.name=Label:
gui.rs_ctr.editor.name=Circuit Editor\:
gui.rs_ctr.state.name=Variables:
gui.rs_ctr.clock.name=Clock Settings
# Gui tooltips
gui.rs_ctr.palette=Gate Palette
gui.rs_ctr.palette.open0=Open Gate Palette
gui.rs_ctr.palette.open1=Open Inventory
gui.rs_ctr.editor.title=Name of your circuit
gui.rs_ctr.opLabel=Gate Label\n§7(relevant for\n§7variables & IO)
gui.rs_ctr.value=Value
gui.rs_ctr.interrupt0=changed value §ndoes not§r trigger next cycle
gui.rs_ctr.interrupt1=changed value triggers next cycle
gui.rs_ctr.editor.del=§4delete Gate
gui.rs_ctr.editor.new=New Schematic\n§4clears the board
gui.rs_ctr.editor.compile=Compile Circuit\n§aR-C§7\: Debugger
gui.rs_ctr.editor.load=Import Schematic
gui.rs_ctr.editor.save=Save Schematic\n§aR-C§7\: export as ...
gui.rs_ctr.editor.ingreds=Circuit Complexity\:\n§c%d / %d basic\n§b%d / %d advanced\n§e%d / %d memory
gui.rs_ctr.editor.info=Controls\nBasic Mechanics\nDebugging / Testing
gui.rs_ctr.editor.info0=§7§nComponent interaction\:§a left-click\n§7To add a component, first click on it in the palette, then on the board where you want to place it.\n§7§oThe palette shows up in place of your inventory when enabled via button.\n§aclick§7 on a component on the board to select it. Configuration options will appear below the bottom left of the boeard.\n§aclick-drag§7 to move a component around [red boxes indicate collision with other components].\n§7Moving a component outside the board area will delete it [bright red box].\n§7§nPin/Trace interaction\:§a right-click\n§7To connect two components with a trace, first §aclick§7 an input pin [left side of a component], then optinally click a few places on the board to lay out its path and finally §aclick§7 another component's output pin [right side].\n§aclick-drag§7 a trace vertex to move it.
gui.rs_ctr.editor.info1=§7In general a circuit receives signals from external devices through its §6input sockets§7, performs some computations on them and produces one or more results that get send back to external devices through its §6output sockets§7. This is refered to as a §ecycle§7.\n\n§6Variables§7 allow a circuit to remember information across cycles. They consist of a §6write§7 component that receives a value in one cycle and a matching [same label] §6read§7 component that spits it out again one cycle later. The read component also defines the variable's initial value. \n\n§7Normally a new cycle gets evaluated with one tick delay after an input or a variable changed its value. But you can set individual §6variable write§7s or §6input§7s to not trigger a cycle if wanted.\n§7§oNote\: changing variable values manually through the Debugger or the processor's status interface won't trigger a cycle.
gui.rs_ctr.editor.info2=§7Although you can overwrite the circuit on a §6processor§7 as often as you like, it is usually a good idea to first test your design with the §edebugger§7 before hooking it up to ... let's say, your nuclear reactor control setup.\n§7The §edebugger§7 window is opened by §aright-click§7 on the §ecompile button§7 (instead of left-click). In there you can feed your circuit with different input values and see how its outputs and variable states behave after executing individual cycles.\n§7The debugger's variable editing feature is also available later in the §6processor§7's §estatus interface§7 (which is opened by normal interaction with the placed block).\n§7Therefore also seemingly useless §eread-only§7 and §ewrite-only§7 variables may be used for later adjustment of parameters or getting more details about the circuit's operation.
gui.rs_ctr.debug.name=Debugger
gui.rs_ctr.debug.run0=automatic execution
gui.rs_ctr.debug.run1=manual execution
gui.rs_ctr.debug.step0=force cycle\n§4§ostable state
gui.rs_ctr.debug.step1=run cycle\n§2§ounstable
gui.rs_ctr.debug.reset=reset count
gui.rs_ctr.state.io=Signal IO\:
gui.rs_ctr.hex0=decimal format
gui.rs_ctr.hex1=hexadecimal format
gui.rs_ctr.interval=Interval
gui.rs_ctr.phase=Phase Offset
gui.rs_ctr.error1=§4causal loop
gui.rs_ctr.error2=§4incompatible data type
gui.rs_ctr.error3=§4missing input signal
gui.rs_ctr.error4=§4invalid identifier
gui.rs_ctr.error5=§4duplicate variable declaration
gui.rs_ctr.error6=§4conflicting writes on same variable
gui.rs_ctr.error7=§4invalid value
gui.rs_ctr.error32=§4missing Processor
gui.rs_ctr.error33=§4circuit too complex\n§4for given Processor
gui.rs_ctr.error34=§4Processor doesn't\nsupport enough I/O
gui.rs_ctr.error64=§6highly recommended\n§6to label your IO ports
gui.rs_ctr.save_file=Export
gui.rs_ctr.load_file=Import
gui.rs_ctr.processor.run=manually trigger cycle
